<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>그림 유사도 추론 게임</title>
  <style>

    #overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      animation: fadeIn 0.6s ease-out;
    }

    #overlay-message {
      color: white;
      font-size: 4rem;
      font-weight: bold;
      text-align: center;
      animation: popIn 0.5s ease-out;
    }

    #close-overlay-button {
      position: absolute;
      bottom: 30px;
      right: 30px;
      padding: 0.6rem 1.2rem;
      font-size: 1.1rem;
      border: none;
      border-radius: 10px;
      background-color: #ffffff;
      color: #333;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s ease, transform 0.2s ease;
    }

    #close-overlay-button:hover {
      background-color: #dddddd;
      transform: scale(1.05);
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes popIn {
      0% {
        transform: scale(0.7);
        opacity: 0;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: #f0f2f5;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    canvas {
      border: 2px solid #333;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    p {
      margin: 0.5rem 0;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .compare-button-wrapper {
      display: flex;
      justify-content: center;
      margin-top: 1.5rem;
    }

    button {
      background-color: #4a90e2;
      border: none;
      color: white;
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }

    button:hover {
      background-color: #357ab8;
    }

    button:active {
      transform: scale(0.98);
    }

    .slider-group {
      display: flex;
      gap: 2rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .slider-group label {
      display: flex;
      flex-direction: column;
      font-size: 0.9rem;
      color: #333;
      align-items: center;
    }

    .slider-group input[type="range"] {
      width: 150px;
    }

    #history-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 240px;
      height: 100vh;
      background-color: #ffffff;
      border-left: 1px solid #ddd;
      padding: 1rem;
      box-shadow: -2px 0 6px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      z-index: 1000;
    }

    #history-panel h3 {
      font-size: 1rem;
      margin-bottom: 0.5rem;
      color: #333;
    }

    #similarity-history {
      list-style: none;
      padding-left: 0;
      margin: 0;
    }

    #similarity-history li {
      margin-bottom: 1rem;
      cursor: pointer;
      font-size: 0.85rem;
    }

    #similarity-history li div {
      color: gray;
      transition: color 0.3s ease;
    }

  </style>
</head>

<div id="overlay" style="display: none;">
  <div id="overlay-message">정답입니다!</div>
  <button id="close-overlay-button">닫기</button>
</div>

<div id="history-panel">
  <h3>Similarity History</h3>
  <ul id="similarity-history"></ul>
</div>

<body>

  <div class="container">
    <p>Click and drag on the canvas to draw or erase.</p>

    <canvas id="canvas1" width="384" height="384"></canvas>

    <p>Loaded Image: <span id="loaded-image-name">None</span></p>
    <p>Similarity: <span id="similarity-result">-</span></p>

    <div class="slider-group">
      <label>
        Pen Size:
        <input type="range" id="pen-size-slider" min="1" max="20" value="2" />
        <span id="pen-size-label">2</span>
      </label>
      <label>
        Eraser Size:
        <input type="range" id="eraser-size-slider" min="1" max="50" value="10" />
        <span id="eraser-size-label">10</span>
      </label>
    </div>

    <div class="button-group">
      <button id="toggle-mode-button">Mode: Draw</button>
      <button id="clear-canvas-button">Clear Canvas</button>
    </div>
    <div class="compare-button-wrapper">
      <button id="compare-button">Compare Similarity</button>
    </div>

  </div>

<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<script>
  // 기존 자바스크립트는 그대로 유지
  let eraseMode = false;
  let cachedImageEmbedding = null;
  let modelSession = null;
  let penSize = 2;
  let eraserSize = 10;
  const historyList = [];

  function setupCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    let drawing = false;

    canvas.addEventListener('mousedown', () => drawing = true);
    canvas.addEventListener('mouseup', () => drawing = false);
    canvas.addEventListener('mouseout', () => drawing = false);

    canvas.addEventListener('mousemove', (event) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      ctx.fillStyle = eraseMode ? 'white' : 'black';
      const radius = eraseMode ? eraserSize : penSize;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
    });
  }


  function getCanvasRGBData(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, 384, 384);
    const data = imageData.data;
    const rgbData = [];

    for (let c = 0; c < 3; c++) {
      for (let i = 0; i < data.length; i += 4) {
        rgbData.push(data[i + c] / 255);
      }
    }
    return rgbData;
  }

  function cosineSimilarity(vec1, vec2) {
    let dot = 0, normA = 0, normB = 0;
    for (let i = 0; i < vec1.length; i++) {
      dot += vec1[i] * vec2[i];
      normA += vec1[i] ** 2;
      normB += vec2[i] ** 2;
    }
    return dot / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  async function runViT(rgbData) {
    const inputTensor = new Float32Array(rgbData);
    const inputShape = [1, 3, 384, 384];
    const feeds = { pixel_values: new ort.Tensor('float32', inputTensor, inputShape) };
    const results = await modelSession.run(feeds);
    const output = results["last_hidden_state"];
    return output.data.slice(0, 768); // CLS token
  }

  async function sendToModel() {
    const canvas = document.getElementById('canvas1');
    const canvas1RGB = getCanvasRGBData(canvas);
    const vec1 = await runViT(canvas1RGB);

    if (!cachedImageEmbedding) {
      alert("Error: reference image embedding not ready.");
      return;
    }

    const similarity = cosineSimilarity(vec1, cachedImageEmbedding);
    document.getElementById('similarity-result').innerText = similarity.toFixed(4);

    const imageDataUrl = canvas.toDataURL(); // 현재 그림 저장
    addToHistory(similarity, imageDataUrl); // 히스토리에 추가

    if (similarity >= 0.7) {
      document.getElementById('overlay').style.display = 'flex';
    }
  }

  async function loadRandomImage(imageList) {
    const randomImage = imageList[Math.floor(Math.random() * imageList.length)];
    document.getElementById("loaded-image-name").innerText = randomImage;

    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = async () => {
      const offscreen = document.createElement("canvas");
      offscreen.width = 384;
      offscreen.height = 384;
      const ctx = offscreen.getContext("2d");
      ctx.drawImage(img, 0, 0, 384, 384);
      const rgbData = getCanvasRGBData(offscreen);
      cachedImageEmbedding = await runViT(rgbData);
      console.log("Reference image embedding ready.");
    };
    img.src = `problems/${randomImage}`;
  }

  function renderHistory() {
    const listContainer = document.getElementById('similarity-history');
    listContainer.innerHTML = '';

    const sortedHistory = [...historyList].sort((a, b) => b.similarity - a.similarity);

    sortedHistory.forEach((entry, index) => {
      const item = document.createElement('li');
      const label = document.createElement('div');
      label.textContent = `${entry.similarity.toFixed(4)}`;
      label.style.fontWeight = 'bold';

      const contentWrapper = document.createElement('div');
      contentWrapper.style.marginTop = '0.5rem';

      let expanded = false;

      label.addEventListener('click', () => {
        contentWrapper.innerHTML = '';
        if (!expanded) {
          // 썸네일 이미지
          const img = new Image();
          img.src = entry.imageDataUrl;
          img.style.width = '150px';
          img.style.border = '1px solid #ccc';
          img.style.borderRadius = '8px';
          img.style.display = 'block';
          img.style.marginBottom = '0.5rem';

          // "캔버스로 불러오기" 버튼
          const loadButton = document.createElement('button');
          loadButton.textContent = '캔버스로 불러오기';
          loadButton.style.marginRight = '0.5rem';
          loadButton.style.padding = '0.3rem 0.6rem';
          loadButton.style.fontSize = '0.8rem';
          loadButton.style.cursor = 'pointer';
          loadButton.addEventListener('click', () => {
            const canvas = document.getElementById('canvas1');
            const ctx = canvas.getContext('2d');
            const imgToLoad = new Image();
            imgToLoad.onload = () => {
              ctx.drawImage(imgToLoad, 0, 0, canvas.width, canvas.height);
            };
            imgToLoad.src = entry.imageDataUrl;
          });

          // 닫기 버튼
          const closeButton = document.createElement('button');
          closeButton.textContent = '닫기';
          closeButton.style.padding = '0.3rem 0.6rem';
          closeButton.style.fontSize = '0.8rem';
          closeButton.style.cursor = 'pointer';
          closeButton.addEventListener('click', () => {
            contentWrapper.innerHTML = '';
            label.style.color = 'gray';
            expanded = false;
          });

          contentWrapper.appendChild(img);
          contentWrapper.appendChild(loadButton);
          contentWrapper.appendChild(closeButton);

          label.style.color = 'black';
          expanded = true;
        } else {
          contentWrapper.innerHTML = '';
          label.style.color = 'gray';
          expanded = false;
        }
      });

      item.appendChild(label);
      item.appendChild(contentWrapper);
      listContainer.appendChild(item);
    });
  }

  function addToHistory(similarity, imageDataUrl) {
    historyList.push({ similarity, imageDataUrl });
    renderHistory();
  }

  document.getElementById('compare-button').addEventListener('click', sendToModel);
  document.getElementById('toggle-mode-button').addEventListener('click', () => {
    eraseMode = !eraseMode;
    document.getElementById('toggle-mode-button').innerText = eraseMode ? 'Mode: Erase' : 'Mode: Draw';
  });
  document.getElementById('clear-canvas-button').addEventListener('click', () => {
    const canvas = document.getElementById('canvas1');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  });

  // 슬라이더 이벤트 리스너
  document.getElementById('pen-size-slider').addEventListener('input', (e) => {
    penSize = parseInt(e.target.value);
    document.getElementById('pen-size-label').innerText = penSize;
  });

  document.getElementById('eraser-size-slider').addEventListener('input', (e) => {
    eraserSize = parseInt(e.target.value);
    document.getElementById('eraser-size-label').innerText = eraserSize;
  });

  document.getElementById('close-overlay-button').addEventListener('click', () => {
    document.getElementById('overlay').style.display = 'none';
  });

  setupCanvas(document.getElementById('canvas1'));

  const imageList = [
    "1.png",
    "2.png",
    "3.png",
    "4.png",
    "5.png"
  ];

  window.onload = async () => {
    modelSession = await ort.InferenceSession.create('vit.onnx');
    await loadRandomImage(imageList);
  };
</script>

</body>
</html>
